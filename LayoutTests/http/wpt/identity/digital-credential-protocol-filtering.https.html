<!DOCTYPE html>
<meta charset="utf-8" />
<title>Digital Credential API: Protocol Filtering Tests</title>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<body></body>
<script>
    promise_setup(async () => {
        if (document.visibilityState === "hidden") {
            await new Promise((resolve) => {
                document.onvisibilitychange = resolve;
                testRunner.setPageVisibility("visible");
            });
        }
        assert_equals(document.visibilityState, "visible", "should be visible");
    });

    const validMDocRequest = {
        protocol: "org-iso-mdoc",
        data: {
            deviceRequest:
                "omd2ZXJzaW9uYzEuMGtkb2NSZXF1ZXN0c4GhbGl0ZW1zUmVxdWVzdNgYWIKiZ2RvY1R5cGV1b3JnLmlzby4xODAxMy41LjEubURMam5hbWVTcGFjZXOhcW9yZy5pc28uMTgwMTMuNS4x9pWthZ2Vfb3Zlcl8yMfRqZ2l2ZW5fbmFtZfRrZmFtaWx5X25hbWX0cmRyaXZpbmdfcHJpdmlsZWdlc_RocG9ydHJhaXT0",
            encryptionInfo:
                "gmVkY2FwaaJlbm9uY2VYICBetSsDkKlE_G9JSIHwPzr3ctt6Ol9GgmCH8iGdGQNJcnJlY2lwaWVudFB1YmxpY0tleaQBAiABIVggKKm1iPeuOb9bDJeeJEL4QldYlWvY7F_K8eZkmYdS9PwiWCCm9PLEmosiE_ildsE11lqq4kDkjhfQUKPpbX-Hm1ZSLg",
        },
    };

    const unknownProtocolRequest1 = {
        protocol: "unknown-protocol-1",
        data: { someField: "someValue" },
    };

    const unknownProtocolRequest2 = {
        protocol: "unknown-protocol-2",
        data: { anotherField: "anotherValue" },
    };

    // test passing just the valid protocol to ensure it works as expected
    promise_test(async (t) => {
        try {
            await navigator.credentials.get({
                digital: {
                    requests: [validMDocRequest],
                },
                mediation: "required",
            });
            assert_unreached(
                "Should not reach here in test environment - no credentials available"
            );
        } catch (error) {
            // Expect some other error, but NOT TypeError which would indicate valid protocol wasn't recognized
            assert_not_equals(
                error.name,
                "TypeError",
                `Should not get TypeError when valid protocol is used: ${error.message}`
            );
        }
    }, "Valid protocol is accepted and processed");

    promise_test(async (t) => {
        await promise_rejects_js(
            t,
            TypeError,
            navigator.credentials.get({
                digital: {
                    requests: [
                        unknownProtocolRequest1,
                        unknownProtocolRequest2,
                    ],
                },
                mediation: "required",
            }),
            "Two unknown protocols should result in TypeError due to empty validated requests"
        );
    }, "Unknown protocols are filtered out - all unknown protocols result in TypeError");

    promise_test(async (t) => {
        await promise_rejects_js(
            t,
            TypeError,
            navigator.credentials.get({
                digital: {
                    requests: [unknownProtocolRequest1],
                },
                mediation: "required",
            }),
            "Single unknown protocol should result in TypeError due to empty validated requests"
        );
    }, "Single unknown protocol is filtered out and results in TypeError");

    promise_test(async (t) => {
        try {
            await navigator.credentials.get({
                digital: {
                    requests: [
                        unknownProtocolRequest1,
                        validMDocRequest,
                        unknownProtocolRequest2,
                    ],
                },
                mediation: "required",
            });
            assert_unreached(
                "Should not reach here in test environment - no credentials available"
            );
        } catch (error) {
            // Expect some other error, but NOT TypeError which would indicate unknown protocols weren't filtered
            assert_not_equals(
                error.name,
                "TypeError",
                `Should not get TypeError when mixing known and unknown protocols - unknown should be filtered out: ${error.message}`
            );
        }
    }, "Mixed known and unknown protocols - unknown ones are silently filtered out");

    promise_test(async (t) => {
        const validMDocRequest2 = {
            protocol: "org-iso-mdoc",
            data: {
                deviceRequest:
                    "omd2ZXJzaW9uYzEuMGtkb2NSZXF1ZXN0c4GhbGl0ZW1zUmVxdWVzdNgYWIKiZ2RvY1R5cGV1b3JnLmlzby4xODAxMy41LjEubURMam5hbWVTcGFjZXOhcW9yZy5pc28uMTgwMTMuNS4x9pWthZ2Vfb3Zlcl8yMfRqZ2l2ZW5fbmFtZfRrZmFtaWx5X25hbWX0cmRyaXZpbmdfcHJpdmlsZWdlc_RocG9ydHJhaXT0",
                encryptionInfo:
                    "gmVkY2FwaaJlbm9uY2VYICBetSsDkKlE_G9JSIHwPzr3ctt6Ol9GgmCH8iGdGQNJcnJlY2lwaWVudFB1YmxpY0tleaQBAiABIVggKKm1iPeuOb9bDJeeJEL4QldYlWvY7F_K8eZkmYdS9PwiWCCm9PLEmosiE_ildsE11lqq4kDkjhfQUKPpbX-Hm1ZSLg",
            },
        };

        try {
            await navigator.credentials.get({
                digital: {
                    requests: [
                        unknownProtocolRequest1,
                        validMDocRequest,
                        unknownProtocolRequest2,
                        validMDocRequest2,
                        { protocol: "yet-another-unknown", data: {} },
                    ],
                },
                mediation: "required",
            });
            assert_unreached(
                "Should not reach here in test environment - no credentials available"
            );
        } catch (error) {
            assert_not_equals(
                error.name,
                "TypeError",
                "Should not get TypeError when valid protocols are present - unknown should be filtered out: " + error.message
            );
        }
    }, "Multiple valid and unknown protocols - unknown ones are filtered out, valid ones processed");

    promise_test(async (t) => {
        await promise_rejects_js(
            t,
            TypeError,
            navigator.credentials.get({
                digital: {
                    requests: [{ protocol: "", data: {} }],
                },
                mediation: "required",
            }),
            "Empty protocol string should result in TypeError"
        );
    }, "Empty protocol string is treated as unknown protocol");

    promise_test(async (t) => {
        await promise_rejects_js(
            t,
            TypeError,
            navigator.credentials.get({
                digital: {
                    requests: [{ protocol: "ORG-ISO-MDOC", data: {} }],
                },
            }),
            "Protocol matching should be case sensitive"
        );
    }, "Protocol matching is case sensitive");

    promise_test(async (t) => {
        await promise_rejects_js(
            t,
            TypeError,
            navigator.credentials.get({
                digital: {
                    requests: [{ protocol: "org-iso-mdoc-extra", data: {} }],
                },
                mediation: "required",
            }),
            "Protocol with extra characters should be treated as unknown"
        );
    }, "Protocol with extra characters is treated as unknown");
</script>
